# ======================================================================
# DOCKER COMPOSE CONFIGURATION FOR DJANGO REAL ESTATE PROJECT
# ======================================================================
#
# PURPOSE:
# This Docker Compose file orchestrates a complete local development
# environment for the Django Real Estate application. It defines and
# coordinates multiple services that work together to provide:
# - Django API backend with PostgreSQL database
# - Next.js frontend client application
# - Nginx reverse proxy for routing and load balancing
# - Mailpit for local email testing and development
# - Shared networking and volume management
#
# ARCHITECTURE:
# Internet → Nginx (port 8080) → {Django API, Next.js Client}
#                               ↓
#                          PostgreSQL Database
#                               ↓
#                          Mailpit (Email Testing)
#
# USAGE:
# - Development: docker-compose -f local.yml up --build
# - Background: docker-compose -f local.yml up -d
# - Rebuild: docker-compose -f local.yml up --build --force-recreate
# - Stop: docker-compose -f local.yml down
# - Clean: docker-compose -f local.yml down -v (removes volumes)
#
# NETWORKING:
# All services communicate via the 'estate_prod_nw' Docker network
# Service names (api, postgres, client, etc.) resolve to container IPs
# ======================================================================

# Project name for Docker Compose stack
# Helps organize containers and resources under a common identifier
name: django_real_estate

# ======================================================================
# SERVICE DEFINITIONS - Application Components
# ======================================================================

services:
  # ======================================================================
  # DJANGO API SERVICE - Backend Application Server
  # ======================================================================
  api: &api  # YAML anchor for reusability in other services
    build:
      context: .  # Build context is the project root directory
      dockerfile: ./docker/local/django/Dockerfile  # Custom Django Dockerfile
    image: estate_prod_api  # Tagged image name for identification
    container_name: estate_prod_api  # Fixed container name for consistency
    
    # Volume mounts for development workflow
    volumes:
        # Mount entire project directory for live code reloading
        # :z flag enables SELinux relabeling for security in SELinux environments
        - .:/app:z
        # Mount static files directory for nginx to serve directly
        - .staticfiles:/app/staticfiles
    
    # Network exposure configuration
    # Using expose instead of ports for internal-only access
    # Nginx proxy handles external access on port 8080
    expose:
      - "8000"  # Django development server port (internal only)
    
    # Environment variables loaded from external file
    # Contains sensitive data like database credentials, API keys
    env_file:
        - ./.envs/.env.local  # Local development environment variables
    
    # Service dependencies - ensures proper startup order
    # Django API requires database and email service to be ready
    depends_on:
        - postgres  # Database must be ready before Django starts
        - mailpit   # Email service should be available for notifications
        - redis 
    # Container startup command
    # Executes the /start script defined in the Django Dockerfile
    command: /start
    
    # Network assignment for inter-service communication
    networks:
      - estate_prod_nw

  # ======================================================================
  # POSTGRESQL DATABASE SERVICE - Data Persistence Layer
  # ======================================================================
  postgres:
    build:
      context: .  # Build from project root
      dockerfile: ./docker/local/postgres/Dockerfile  # Custom PostgreSQL setup
    image: estate_prod_postgres  # Tagged image for PostgreSQL
    container_name: estate_prod_postgres  # Fixed container name
    
    # Port mapping for external database access
    # Allows connection from host system tools (pgAdmin, psql, etc.)
    ports:
      - "5432:5432"  # Standard PostgreSQL port mapped to host
    
    # Persistent data storage
    # Database data survives container restarts and rebuilds
    volumes:
      - estate_prod_postgres_data:/var/lib/postgresql/data
    
    # Database configuration via environment variables
    # Includes database name, credentials, and connection settings
    env_file:
      - ./.envs/.env.local
    
    networks:
      - estate_prod_nw

  # ======================================================================
  # MAILPIT SERVICE - Local Email Testing and Development
  # ======================================================================
  mailpit:
    # Official Mailpit image for email capture and testing
    # Provides SMTP server and web UI for email inspection
    image: docker.io/axllent/mailpit:v1.15
    container_name: estate_prod_mailpit
    
    # Port mappings for email services
    ports:
      - "8025:8025"  # Web UI for viewing captured emails
      - "1025:1025"  # SMTP server for receiving emails from Django
    
    # Persistent email storage
    # Captured emails survive container restarts
    volumes:
      - estate_prod_mailpit_data:/data
    
    # Mailpit-specific configuration
    environment:
        MP_MAX_MESSAGES: 5000              # Maximum stored emails
        MP_DATA_FILE: /data/mailpit.db     # Database file location
        MP_SMTP_AUTH_ACCEPT_ANY: 1         # Accept any SMTP auth (dev only)
        MP_SMTP_AUTH_ALLOW_INSECURE: 1     # Allow insecure auth (dev only)
    
    networks:
      - estate_prod_nw

  # ======================================================================
  # NEXT.JS CLIENT SERVICE - Frontend Application Server
  # ======================================================================
  client:
    build:
      context: ./client  # Build context is the client directory
      dockerfile: ./docker/local/Dockerfile  # Next.js Dockerfile in client folder
    container_name: estate_client
    image: estate_client
    
    # Internal port exposure only
    # Nginx handles external routing to this service
    expose:
      - "3000"  # Next.js development server port
    
    # Volume mounts for Next.js development
    volumes:
        - ./client:/app  # Mount client code for hot reloading
        - /app/node_modules  # Preserve node_modules in container (performance)
    
    networks:
        - estate_prod_nw

  redis:  
    image: "redis:7.0-alpine3.19"
    command: redis-server --appendonly yes
    container_name: estate_redis
    volumes:
      - estate_redis_prod_data:/data  
    ports:
      - "6379:6379"
    networks:
      - estate_prod_nw

  celeryworker:
    <<: *api  # Reuse api service configuration via YAML anchor
    image: estate_prod_celery_worker  
    container_name: estate_prod_celery_worker  
    command: /start-celeryworker

  celerybeat:
    <<: *api  # Reuse api service configuration via YAML anchor
    image: estate_prod_celery_beat  
    container_name: estate_prod_celery_beat  
    command: /start-celerybeat

  flower:
    <<: *api  # Reuse api service configuration via YAML anchor
    image: estate_prod_flower
    container_name: estate_prod_flower
    ports:
      - "5555:5555"  # Flower monitoring UI port mapping
    command: /start-flower



  # ======================================================================
  # NGINX REVERSE PROXY SERVICE - Load Balancer and Static File Server
  # ======================================================================
  nginx:
    build:
      context: ./docker/local/nginx  # Build context is nginx configuration directory
      dockerfile: Dockerfile  # Custom nginx Dockerfile
    restart: always  # Auto-restart on failure for reliability
    container_name: estate_nginx
    
    # External port mapping - main application entry point
    ports:
      - "8080:80"  # Map host port 8080 to nginx port 80
    
    # Volume mounts for nginx functionality
    volumes:
      # Mount static files for direct serving (better performance than Django)
      - .staticfiles:/app/staticfiles
      # Mount custom nginx configuration (read-only for security)
      - ./docker/local/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # Mount logs directory for access and error log persistence
      - logs_store:/var/log/nginx
    
    # Nginx depends on backend services being ready
    # Ensures API is available before nginx starts routing requests
    depends_on:
      - api  # Django API must be running before nginx starts
    
    networks:
        - estate_prod_nw

# ======================================================================
# NETWORK CONFIGURATION - Inter-Service Communication
# ======================================================================

# Define Docker networks for service communication
networks:
  estate_prod_nw:  # Custom network name for the application stack
    external: true  # Network must be created manually before docker-compose
    # Create with: docker network create estate_prod_nw
    # Benefits: Isolation, custom naming, shared across multiple compose files

# ======================================================================
# VOLUME DEFINITIONS - Persistent Data Storage
# ======================================================================

# Named volumes for data persistence across container lifecycles
volumes:
      # PostgreSQL database data persistence
      # Survives container restarts, rebuilds, and updates
      estate_prod_postgres_data: {}
      
      # Mailpit email data persistence
      # Preserves captured emails across container restarts
      estate_prod_mailpit_data: {}
      
      # Nginx logs persistence
      # Maintains access and error logs for analysis and debugging
      logs_store: {}
      estate_redis_prod_data: {}

# ======================================================================
# DEVELOPMENT WORKFLOW NOTES
# ======================================================================
#
# FIRST TIME SETUP:
# 1. Create external network: docker network create estate_prod_nw
# 2. Copy .envs/.env.local.example to .envs/.env.local
# 3. Configure environment variables in .env.local
# 4. Build and start: docker-compose -f local.yml up --build
#
# DAILY DEVELOPMENT:
# - Start services: docker-compose -f local.yml up
# - View logs: docker-compose -f local.yml logs -f [service_name]
# - Execute commands: docker-compose -f local.yml exec api python manage.py [command]
# - Stop services: docker-compose -f local.yml down
#
# SERVICE ACCESS:
# - Application: http://localhost:8080
# - API docs: http://localhost:8080/swagger
# - Admin panel: http://localhost:8080/supersecret
# - Mailpit UI: http://localhost:8025
# - Database: localhost:5432 (use credentials from .env.local)
#
# TROUBLESHOOTING:
# - View container status: docker-compose -f local.yml ps
# - Check service logs: docker-compose -f local.yml logs [service_name]
# - Rebuild specific service: docker-compose -f local.yml up --build [service_name]
# - Reset volumes: docker-compose -f local.yml down -v
# ======================================================================

