We shall now be implementing token based authentication, user registration and account management.

We shall be using the Jozsa package for this.

By default, Jozsa sends an access and refresh tokens as part of the response body.

For the kind of application we are building, we want these tokens returned as secure HTTP only cookies,

which is the standard right now.

This is because in the front end, we don't want to store our tokens in local storage.

Storing the tokens in local storage poses a security risk, since they can be accessed through client

side JavaScript.

HTTP only cookies are considered more secure, but they also have their disadvantages.

Always remember that when building software applications, it's all about trade offs.

No tool or strategy is 100% foolproof.

So first again to configure our cookies.

So where are we going to do that.

Go back to your IDE.

Then let's close all this.

And then we're going to go to our base dot pi file settings base dot pi file.

And then at the bottom let's configure our cookies.

So we're going to give our cookies a name.

And so you can say cookie underscore name.

And we're just going to call ours access like that.

We're going to have another setting for cookie underscore same site.

And we're going to set that to LAX just like that.

And so when setting the cookie samesite attribute to LAX, it means that the cookie will be sent with

the same site request.

And with cross-site top level navigations.

The lax setting provides a balance between security and usability.

It helps protect against CSRF attacks by not sending cookies with potentially dangerous cross-site requests,

while still allowing the cookie to be sent to the top level navigations that are typically initiated

by user actions.

And then we're going to set a cookie underscore path.

And again, to set that to slash just like that, by setting the cookie path to the slash, it means

you're setting the cookie path to the root, meaning the cookie will be available for all paths under

the domain.

This is common for cookies that need to be accessed by the entire application.

Then we can say a cookie underscore HTTP only.

We're going to set that to a true.

That's when a cookie is set with the httponly flag.

It means that the cookie cannot be accessed or manipulated by client side JavaScript.

This restriction is enforced by the web browser.

If a web application is vulnerable to cross-site scripting attacks, the Httponly flag can help prevent

an attacker from gaining access to sensitive cookie session information.

And the next we're going to see cookie underscore secure.

And we're going to set this to our environment variable.

So you can say getenv.

We're going to try to look for the cookie secure environment variable.

If it doesn't exist we're going to set the default value to true.

And we can equate that to true.

So double equal sign and set that to true.

So this cookie secure setting in Django determines whether cookies should be sent only over secure Https

connections, or can be sent over both HTTP and Https connection.

And so in cookie, secure is set to true.

It means that cookies will only be sent over secure Https connections.

This helps protect sensitive information, such as session cookies, from being intercepted or manipulated

by unauthorized parties.

So here we are.

We're seeing Getenv cookie secure is true.

We're going to retrieve the value of cookie secure from the environment variable.

If the environment variable is not set, we're going to default it to true.

Then double equal sign are true.

Compares the retrieved value or the default value.

So these two values with the string of true.

If they are equal, the expression evaluates to true.

Otherwise it evaluates to false.

And then here I made a mistake, a get rid of that bracket and that comma and that it's just supposed

to be like this getenv cookie secure, then true.

Then double equals true like that.

Then you can save the base.py file.

And as I mentioned before, Josa by default sends the access and refresh tokens as part of the response

body for the application we are building.

We also want our tokens to be sent as cookies.

So for this to happen we have to create a custom authentication class.

This class will authenticate users via JWT tokens and return the tokens as cookies.

So we're going to go back to application, then go back to our common app.

Also within command.

We're going to create a new file here.

Let's just rename tests in common.

We can rename this to uh cookie underscore underscore auth dot pi.

So this is under co underscore aps command.

Then cookie underscore auth dot pi.

Then let's create this custom authentication class.

As usual, we're going to start with our imports.

So you can import logging.

Then from typing we're going to import optional.

On the tuple.

Then from Django conf we're going to import settings.

Then from our Rest framework dot request we're going to import request.

Then from a Rest framework underscore simple JWT dot authentication.

We're going to import a JWT authentication and the auth user.

Then from a Rest framework underscore simple JWT dot exceptions we're going to import the token error.

And then from Rest framework and underscore simple JWT dot tokens we're going to import token.

Then create an instance of our logger.

So you can say logger is going to be logging dot get logger.

And here you can pass double underscore name.

And then create our authentication class.

So you can see class I can call this cookie.

Authentication.

It's going to subclass JWT authentication.

Then we're going to override the authenticate method and return an optional tuple with the auth user.

As you can see define authenticate it's going to take in self request with the type of request.

Then it's going to return an optional.

An optional tuple.

So we have the square brackets with a auth user.

Also can just get rid of all this with the auth user comma or the token.

Then get rid of this.

So it's like that.

So define authenticate takes in self.

Then the request returns an optional tuple with the auth user and the token.

And so fast.

In this function we're going to attempt to retrieve the JWT token from the request header using the

get header method.

So you can just say header is going to be a self dot get underscore header.

It takes in the request.

Then we're going to initialize our raw token to none.

So you can say raw underscore token.

We can set this to none.

Then we're going to have an if condition, which is going to check if there's an authorization header.

If so, it's going to extract the row token using the row token method.

So you can see if header.

Is not none.

Then the Ro token is going to be self dot get Ro token passing in the header.

Else if.

In settings you can say settings dot cookie name.

So if the cookie name exists in request dot cookies, this Elif condition checks if a specific cookie

with the name specified in settings dot cookie name exists in the request.

If the cookie exists, we are going to assign the value of the cookie to the row token, so we can say

if that exists, we're going to say row token and this is going to be a request.

Whoa.

Uh, request dot cookies.

Dude, get your settings.

Dude.

Cookingham.

It just like that.

Then we're going to proceed.

Now, if a raw JWT token is found either in the header or in the cookie, we're going to write code

to attempt to validate it with the get validate method.

As you can see, if this raw token is not none meaning it exists, we're going to have a try catch block.

So try not try catch.

This is not JavaScript.

This is try except where in Python land.

So this is try.

Then you can have an accept block.

And so I think let's start with a try.

And so for the try block we can say the validated token.

Is going to be self dot get validated token.

And you going to pass in our arrow token.

And then if the token is valid, we're going to return a tuple consisting of the user and the validated

token.

This tuple is what will be used by the Django Rest framework to set the user and auth in the request,

so we can return self dot get user.

And you going to pass in the validated token and then comma and the validated token just like that.

And then in the except block.

If an error occurs during token validation, such as if the token has expired or is invalid, we are

going to catch it using the token error exception.

As you can see, except token error as e, we are going to log this so you can say logger dot error.

And here we can see, let's say token a validation error.

Then we're going to pass in an error as a string.

So in curly braces we're going to say str.

Then passing the error.

I just like that.

Then after I accept block and setting in our logger, we're now going to just enter B at the same level

as this if block.

So at this level we're just going to return.

None like that.

So at this level the authenticate method is returning none.

If no token is found or if the token is invalid.

So just countercheck and make sure you get the indentation right and this code right.

If this custom class is a bit confusing, just take a time and go through it step by step.

Then you can save our custom or cookie authentication class.

Then in our dot env local file we're going to add the Cookie Secure environment variable.

So go back to envs.

Then MPs dot local.

We're just going to go let's say above the Cloudinary stuff.

And we're going to set a caps lock cookie underscore secure.

And since we in development.

We're going to set this to false, and you're setting it to false to allow for cookies to be sent via

HTTP.

And since we're still in development, remember the settings we set the cookies secure to default to

true and cookies secure.

Defaulting to true means send cookies only via Https.

But since we're in development, we're setting this to false temporarily to allow cookies to be sent

over HTTP, which is not secure, but is what we are going to use for development.

In production.

Of course, we're going to change this to true.

As you can save that file and then remember to do the same in the env example file.

Also you can copy that and go back to env dot example.

Then paste it in.

Then just remove the value and then you save that file.

And that's basically it for this lecture.

In the next lecture we're going to be configuring the Rest framework and a simple JWT.


