upstream api{
    server api:8000;
}

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''  close;
}

upstream client {
    server client:3000;
}

server{
    listen 80;
    client_max_body_size 20M;
    error_log /var/log/nginx/error.log error;

    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    location /api/v1 {
        # preserve the full request URI so upstream sees /api/v1/paths
        proxy_pass http://api;
        access_log /var/log/nginx/api_access.log;
        error_log /var/log/nginx/api_error.log error;
    }

    # proxy all /api/ requests (including /api/schema/) to the django api
    location /api/ {
        # preserve full request URI so Django receives /api/... paths
        proxy_pass http://api;
        access_log /var/log/nginx/api_access.log;
        error_log /var/log/nginx/api_error.log error;
        # allow cross-origin requests for API schema/docs (Redoc may fetch with CORS)
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization,Content-Type" always;
        # quick handling for OPTIONS preflight
        if ($request_method = OPTIONS) {
            add_header Content-Length 0;
            add_header Content-Type "text/plain charset=UTF-8";
            return 204;
        }
    }

#     Line-by-line explanation

# location /api/ { ... }

# Matches any request path that starts with /api/ (for example /api/schema/, /api/v1/..., etc.). Nginx will apply this block to those requests.
# proxy_pass http://api;

# Forwards the matched request to the upstream named api (defined earlier as server api:8000). Because the proxy_pass has no trailing slash, 
# nginx will preserve the original request URI when proxying (so /api/schema/ remains /api/schema/ on the upstream).
# Upstream api is the service name in Docker Compose, so nginx inside the compose network can reach http://api:8000.
# access_log /var/log/nginx/api_access.log;

# Writes request entries for this location to the specified access log file so you can inspect requests and responses that hit /api/*.
# error_log /var/log/nginx/api_error.log error;

# Writes location-specific errors to this error log file at error severity.
# add_header Access-Control-Allow-Origin "*" always;

# Adds the CORS response header Access-Control-Allow-Origin: * so browsers will allow pages from any origin to read the response.
# The always flag instructs nginx to add the header even on non-200 responses. This is useful when the upstream may return 4xx/5xx 
# but you still want browsers to receive the header.
# add_header Access-Control-Allow-Methods "GET, OPTIONS" always;

# Informs browsers which methods are allowed in cross-origin requests. Here we allow GET and OPTIONS. Swagger/Redoc 
# typically GET the schema; OPTIONS is for preflight.
# add_header Access-Control-Allow-Headers "Authorization,Content-Type" always;

# Tells browsers which request headers (like Authorization) the client may send. Swagger UI or other clients might send Authorization.
# if ($request_method = OPTIONS) { ... return 204; }

# A simple server-side shortcut for handling CORS preflight requests:
# If the request method is OPTIONS (a preflight), immediately return a 204 No Content with some headers.
# This avoids forwarding OPTIONS to the Django app and simplifies preflights, since many apps do not expect or handle OPTIONS 
# for arbitrary routes.
# The block sets Content-Length and Content-Type so the response is valid and minimal.
# Why this was added

# Redoc (and Swagger UI) run in the browser and fetch /api/schema/ via XHR/fetch. That is cross-origin if the page origin 
# differs from the API origin. Browsers block cross-origin responses unless the server includes CORS headers.
# Previously some requests were reaching the Next client instead of the API, and the browser got HTML (404) or redirects. 
# Adding an explicit /api/ proxy ensures those requests hit the Django API and adding CORS headers makes the browser accept the responses.
# Caveats and safer alternatives

# Access-Control-Allow-Origin: "*" is permissive. For development it's fine, but for production consider restricting to 
# the actual origin (e.g., Access-Control-Allow-Origin: https://example.com) or use add_header Access-Control-Allow-Origin $http_origin always; with validation.
# Nginx if is sometimes dangerous when used badly. This particular if ($request_method = OPTIONS) pattern is common and 
# acceptable for simple preflight handling, but avoid complex logic inside if. Alternatively you can add a dedicated location for preflight handling:
# location /api/ { ... }
# location /api/ { if ($request_method = OPTIONS) { ... } } (current)
# or: location /api/ { ... } location /api/ { limit_except GET { ... } } (less common)
# Ordering: exact matches (e.g., location = /api/schema/) can be defined to override prefix matches if needed. 
# You already have explicit exact matches for schema.
# How this affects Swagger UI

# Swagger UI will fetch the schema from /api/schema/ in the browser. With these headers and proxying, the schema 
# fetch should succeed (browser allowed, returned YAML/JSON).
# If Swagger UI attempts an authenticated fetch (with cookies), you may need Access-Control-Allow-Credentials: true 
# and avoid "*" origin; also the browser will only send credentials if the JS request sets credentials: 'include'.
    # explicitly forward the OpenAPI schema paths to the api service to avoid
    # any accidental handling by the client upstream
    location = /api/schema/ {
        proxy_pass http://api;
            access_log /var/log/nginx/api_access.log;
            error_log /var/log/nginx/api_error.log error;
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization,Content-Type" always;
    }

    location = /api/schema {
        proxy_pass http://api;
        access_log /var/log/nginx/api_access.log;
        error_log /var/log/nginx/api_error.log error;
    }

    location /supersecret {
    # keep the original request path so django receives /supersecret/... correctly
        proxy_pass http://api;
            access_log /var/log/nginx/admin_access.log;    
    }
    location / {
        proxy_pass http://client;
        
    }

    location /redoc{
        # redoc page is served by the api; preserve request URI
        proxy_pass http://api;
    }

    # swagger UI served by drf-spectacular - forward to api
    location /swagger {
        proxy_pass http://api;
        access_log /var/log/nginx/api_access.log;
        error_log /var/log/nginx/api_error.log error;
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization,Content-Type" always;
    }

    location /static {
        alias /app/staticfiles;
        expires 30d;
        
        add_header Cache-Control "public, max-age=2592000";
    }
}
